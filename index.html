<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Map Extract — Georeference & Export</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{--accent:#0077ff}
  body{font-family:Arial, sans-serif; margin:0; padding:24px; background:#f6f7fb; color:#222}
  .container{max-width:1200px;margin:0 auto;background:#fff;border-radius:10px;padding:18px;box-shadow:0 6px 30px rgba(10,20,40,0.06)}
  header{display:flex;align-items:center;justify-content:space-between;gap:12px}
  h1{margin:0;font-size:20px;color:#06345a}
  .controls{display:flex;gap:8px;align-items:center}
  button{background:var(--accent);color:#fff;border:none;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600}
  .muted-btn{background:#eef4ff;color:#06345a;border:1px solid #dbeafe}
  .secondary{background:#f2f6fb;color:#06345a;border:1px solid #dbeafe}
  .danger{background:#ffe9ec;color:#7a1220;border:1px solid #e9b5be}
  main{display:grid;grid-template-columns:1fr 360px;gap:18px;margin-top:16px}
  #left{min-height:420px}
  .upload-box{border:2px dashed var(--accent);padding:16px;border-radius:10px;text-align:center;background:#f8fbff}
  canvas{display:block;width:100%;max-height:75vh;border:1px solid #e6e9ef;background:#fff}
  table{width:100%;border-collapse:collapse;margin-top:8px}
  td,th{padding:6px;border-bottom:1px solid #f0f2f6;font-size:13px}
  .small{font-size:13px;color:#666}
  .status{margin-top:8px;color:#333}
  input[type="number"]{width:120px;padding:6px;border-radius:6px;border:1px solid #dbe3ee}
</style>
</head>
<body>
<div class="container">
  <header>
    <h1>Map Extract — Georeference + Export</h1>
    <div class="controls">
      <button id="btn-georef" class="muted-btn">Georeference Mode</button>
      <button id="btn-clear-gcps" class="secondary">Clear GCPs</button>
      <button id="btn-compute" class="secondary">Compute Transform</button>
      <button id="btn-export-geojson" class="secondary">Export Selection GeoJSON</button>
    </div>
  </header>

  <main>
    <section id="left">
      <div class="upload-box">
        <button id="select-pdf">Select PDF</button>
        <input type="file" id="file-input" accept="application/pdf" style="display:none" />
      </div>

      <canvas id="pdf-canvas"></canvas>
      <div class="status" id="status">Status: idle</div>
    </section>

    <aside id="right">
      <h3 style="margin-top:0">Ground Control Points (GCPs)</h3>
      <div class="small">Click on the map in Georeference Mode to add pixel points; then enter lon/lat.</div>

      <table id="gcp-table">
        <thead><tr><th>px X</th><th>px Y</th><th>lon</th><th>lat</th><th></th></tr></thead>
        <tbody></tbody>
      </table>

      <div style="margin-top:10px">
        <label class="small">Model:</label><br>
        <select id="model-select">
          <option value="affine">Affine (3+ points)</option>
          <option value="poly2">2nd-degree Polynomial (6+ points)</option>
        </select>
      </div>

      <div style="margin-top:12px">
        <div class="small">RMS error:</div>
        <div id="rms" style="font-weight:700;margin-top:4px">—</div>
      </div>
    </aside>
  </main>
</div>

<!-- PDF.js -->
<script src="./libs/pdf.js"></script>
<script>
pdfjsLib.GlobalWorkerOptions.workerSrc = "./libs/pdf.worker.js";
</script>

<!-- Basic SAM stub -->
<script src="./libs/sam.js"></script>

<script>
/* ========= LINEAR ALGEBRA HELPERS ========= */
function transpose(A){
  return A[0].map((_,i)=>A.map(row=>row[i]));
}
function matMul(A,B){
  const m=A.length, n=B[0].length, p=B.length;
  const R=Array.from({length:m},()=>Array(n).fill(0));
  for(let i=0;i<m;i++)
    for(let j=0;j<n;j++)
      for(let k=0;k<p;k++)
        R[i][j]+=A[i][k]*B[k][j];
  return R;
}
function matVecMul(A,v){
  return A.map(row=>row.reduce((s,x,i)=>s+x*v[i],0));
}
function solveLinear(A,b){
  A=A.map(r=>r.slice());
  b=b.slice();
  const n=A.length;
  for(let i=0;i<n;i++){
    let max=i;
    for(let r=i+1;r<n;r++) if(Math.abs(A[r][i])>Math.abs(A[max][i])) max=r;
    if(max!==i){ [A[i],A[max]]=[A[max],A[i]]; [b[i],b[max]]=[b[max],b[i]]; }
    const pivot=A[i][i];
    if(Math.abs(pivot)<1e-12) throw new Error("Singular matrix");
    for(let j=i;j<n;j++) A[i][j]/=pivot;
    b[i]/=pivot;
    for(let r=0;r<n;r++){
      if(r===i) continue;
      const f=A[r][i];
      for(let j=i;j<n;j++) A[r][j]-=f*A[i][j];
      b[r]-=f*b[i];
    }
  }
  return b;
}
function leastSquares(M,y){
  const MT=transpose(M);
  const MTM=matMul(MT,M);
  const MTy=matVecMul(MT,y);
  return solveLinear(MTM,MTy);
}

/* ========= TRANSFORM FITTING ========= */
function fitAffine(gcps){
  const M = gcps.map(g=>[1,g.x,g.y]);
  const X = gcps.map(g=>g.X);
  const Y = gcps.map(g=>g.Y);
  const a = leastSquares(M,X);
  const b = leastSquares(M,Y);
  const mapFn = p => ({
    X: a[0] + a[1]*p.x + a[2]*p.y,
    Y: b[0] + b[1]*p.x + b[2]*p.y
  });
  const rms = Math.sqrt(gcps.reduce((s,g)=>{
    const p=mapFn(g); return s + (p.X-g.X)**2 + (p.Y-g.Y)**2;
  },0)/gcps.length);
  return {mapFn,rms};
}

function fitPoly2(gcps){
  const M = gcps.map(g=>[1,g.x,g.y,g.x*g.x,g.x*g.y,g.y*g.y]);
  const X = gcps.map(g=>g.X);
  const Y = gcps.map(g=>g.Y);
  const a = leastSquares(M,X);
  const b = leastSquares(M,Y);
  const mapFn = p => {
    const v=[1,p.x,p.y,p.x*p.x,p.x*p.y,p.y*p.y];
    return {
      X:v.reduce((s,_,i)=>s+v[i]*a[i],0),
      Y:v.reduce((s,_,i)=>s+v[i]*b[i],0)
    };
  };
  const rms = Math.sqrt(gcps.reduce((s,g)=>{
    const p=mapFn(g); return s + (p.X-g.X)**2 + (p.Y-g.Y)**2;
  },0)/gcps.length);
  return {mapFn,rms};
}

/* ========= APP LOGIC ========= */
const canvas=document.getElementById("pdf-canvas");
const ctx=canvas.getContext("2d");
const fileInput=document.getElementById("file-input");
const selectPdf=document.getElementById("select-pdf");
const btnGeoref=document.getElementById("btn-georef");
const btnClear=document.getElementById("btn-clear-gcps");
const btnCompute=document.getElementById("btn-compute");
const btnExport=document.getElementById("btn-export-geojson");
const status=document.getElementById("status");
const gcpTable=document.querySelector("#gcp-table tbody");
const rmsEl=document.getElementById("rms");
const modelSelect=document.getElementById("model-select");

let renderedImage=null;
let georefMode=false;
let gcps=[];
let lastComputed=null;

// For rectangle selection:
let selecting=false, sX=0, sY=0, curRect=null;

selectPdf.onclick=()=>fileInput.click();
fileInput.onchange=async()=>loadPDF();

async function loadPDF(){
  const f=fileInput.files[0];
  if(!f) return;
  status.textContent="Loading PDF...";
  const ab=await f.arrayBuffer();
  const pdf=await pdfjsLib.getDocument({data:ab}).promise;
  const page=await pdf.getPage(1);
  const viewport=page.getViewport({scale:2});
  canvas.width=viewport.width;
  canvas.height=viewport.height;
  await page.render({canvasContext:ctx,viewport}).promise;
  renderedImage=new Image();
  renderedImage.src=canvas.toDataURL();
  await renderedImage.decode();
  status.textContent="PDF loaded.";
}

function redrawBase(){
  if(renderedImage) ctx.drawImage(renderedImage,0,0);
  // Draw GCP markers
  gcps.forEach(g=>{
    ctx.fillStyle="rgba(0,120,255,0.9)";
    ctx.beginPath();
    ctx.arc(g.x,g.y,4,0,Math.PI*2);
    ctx.fill();
  });
}

/* ========= GCP MODE ========= */
btnGeoref.onclick=()=>{
  georefMode=!georefMode;
  btnGeoref.textContent = georefMode ? "Exit Georeference Mode" : "Georeference Mode";
  btnGeoref.className = georefMode ? "danger" : "muted-btn";
  redrawBase();
};

btnClear.onclick=()=>{
  gcps=[]; refreshTable(); lastComputed=null; rmsEl.textContent="—";
  redrawBase();
};

canvas.addEventListener("click",(e)=>{
  if(!georefMode || !renderedImage) return;

  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;

  const x = (e.clientX - rect.left) * scaleX;
  const y = (e.clientY - rect.top) * scaleY;

  gcps.push({x,y,X:null,Y:null});
  refreshTable();
  redrawBase();
});

function refreshTable(){
  gcpTable.innerHTML="";
  gcps.forEach((g,i)=>{
    const row=document.createElement("tr");

    const px=document.createElement("td"); px.textContent=g.x.toFixed(1);
    const py=document.createElement("td"); py.textContent=g.y.toFixed(1);

    const lon=document.createElement("td");
    const lonInput=document.createElement("input");
    lonInput.type="number"; lonInput.step="any"; lonInput.value=g.X ?? "";
    lonInput.onchange=()=>g.X=parseFloat(lonInput.value);
    lon.appendChild(lonInput);

    const lat=document.createElement("td");
    const latInput=document.createElement("input");
    latInput.type="number"; latInput.step="any"; latInput.value=g.Y ?? "";
    latInput.onchange=()=>g.Y=parseFloat(latInput.value);
    lat.appendChild(latInput);

    const del=document.createElement("td");
    const btn=document.createElement("button");
    btn.textContent="X"; btn.className="secondary";
    btn.onclick=()=>{gcps.splice(i,1);refreshTable();redrawBase();};
    del.appendChild(btn);

    row.appendChild(px);row.appendChild(py);row.appendChild(lon);row.appendChild(lat);row.appendChild(del);
    gcpTable.appendChild(row);
  });
}

/* ========= COMPUTE TRANSFORM ========= */
btnCompute.onclick=()=>{
  const valid=gcps.filter(g=>typeof g.X==="number" && typeof g.Y==="number");
  if(modelSelect.value==="affine" && valid.length<3){
    alert("Affine requires 3+ points."); return;
  }
  if(modelSelect.value==="poly2" && valid.length<6){
    alert("Polynomial requires 6+ points."); return;
  }
  try{
    lastComputed = modelSelect.value==="affine"
      ? fitAffine(valid)
      : fitPoly2(valid);

    rmsEl.textContent = lastComputed.rms.toFixed(3);
    status.textContent="Transform computed.";
    redrawBase();
  }catch(err){
    alert("Failed to compute transform: "+err);
  }
};

/* ========= RECTANGLE SELECTION (with FIXED COORDS) ========= */
canvas.addEventListener("mousedown",(e)=>{
  if(georefMode || !renderedImage) return;

  const rect=canvas.getBoundingClientRect();
  const scaleX=canvas.width / rect.width;
  const scaleY=canvas.height / rect.height;

  selecting=true;
  sX=(e.clientX - rect.left) * scaleX;
  sY=(e.clientY - rect.top) * scaleY;

  curRect={x:sX,y:sY,w:0,h:0};
});

canvas.addEventListener("mousemove",(e)=>{
  if(!selecting || !renderedImage) return;

  const rect=canvas.getBoundingClientRect();
  const scaleX=canvas.width / rect.width;
  const scaleY=canvas.height / rect.height;

  const mx=(e.clientX - rect.left) * scaleX;
  const my=(e.clientY - rect.top) * scaleY;

  curRect.w = mx - sX;
  curRect.h = my - sY;

  redrawBase();

  ctx.strokeStyle="red";
  ctx.lineWidth=2;
  ctx.strokeRect(curRect.x,curRect.y,curRect.w,curRect.h);
  ctx.fillStyle="rgba(255,0,0,0.15)";
  ctx.fillRect(curRect.x,curRect.y,curRect.w,curRect.h);
});

canvas.addEventListener("mouseup",()=>{
  selecting=false;
  status.textContent="Rectangle selected.";
});

/* ========= EXPORT ========= */
btnExport.onclick=()=>{
  if(!curRect){ alert("Draw a rectangle first."); return; }
  if(!lastComputed){ alert("Compute transform first."); return; }

  const {mapFn}=lastComputed;

  const pts=[
    {x:curRect.x,y:curRect.y},
    {x:curRect.x+curRect.w,y:curRect.y},
    {x:curRect.x+curRect.w,y:curRect.y+curRect.h},
    {x:curRect.x,y:curRect.y+curRect.h},
    {x:curRect.x,y:curRect.y}
  ];

  const coords=pts.map(p=>{
    const g=mapFn(p);
    return [g.X,g.Y];
  });

  const feature={
    type:"Feature",
    properties:{},
    geometry:{type:"Polygon", coordinates:[coords]}
  };

  const fc={type:"FeatureCollection",features:[feature]};
  const blob=new Blob([JSON.stringify(fc,null,2)],{type:"application/json"});
  const url=URL.createObjectURL(blob);
  const a=document.createElement("a");
  a.href=url; a.download="selection.geojson"; a.click();
  URL.revokeObjectURL(url);
};
</script>
</body>
</html>
