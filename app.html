<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Map Extract ‚Äî App</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root { --accent:#0077ff; }
  body {
    margin:0;
    font-family:-apple-system, BlinkMacSystemFont, "Helvetica Neue", Arial, sans-serif;
    background:#f6f7fb;
    color:#222;
    line-height:1.6;
  }
  nav {
    position: sticky;
    top: 0;
    z-index: 999;
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    border-bottom: 1px solid #eee;
    padding: 14px 32px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    box-shadow: 0 2px 6px rgba(0,0,0,0.04);
  }
  nav h1 {
    margin: 0;
    font-size: 20px;
    font-weight: 600;
    color: #222;
  }
.header {
  position: sticky;
  top: 0;
  background: white;
  border-bottom: 1px solid #ddd;
  padding: 12px 20px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  z-index: 10;
}

.logo {
  font-size: 22px;
  font-weight: bold;
  color: #000;
}

.logo a {
  text-decoration: none;
  color: #000;
}

.nav a {
  margin-left: 20px;
  text-decoration: none;
  color: #333;
  font-weight: bold;
}

.nav a:hover {
  color: #0077ff;
}

  .container {
    max-width:1200px;
    margin:24px auto;
    background:#fff;
    border-radius:10px;
    padding:18px;
    box-shadow:0 6px 30px rgba(10,20,40,0.06);
  }
  header {
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
  }
  header h2 {
    margin:0;
    font-size:20px;
    color:#06345a;
  }
  .controls {
    display:flex;
    gap:8px;
    align-items:center;
    flex-wrap:wrap;
  }
  button {
    background:var(--accent);
    color:#fff;
    border:none;
    padding:8px 12px;
    border-radius:8px;
    cursor:pointer;
    font-weight:600;
  }
  .muted-btn { background:#eef4ff; color:#06345a; border:1px solid #dbeafe; }
  .secondary { background:#f2f6fb; color:#06345a; border:1px solid #dbeafe; }
  .danger { background:#ffe9ec; color:#7a1220; border:1px solid #e9b5be; }

  main {
    display:grid;
    grid-template-columns:1fr 360px;
    gap:18px;
    margin-top:16px;
  }
  #left {
    position: relative;
    z-index: 5;
  }

  #right {
    position: relative;
    z-index: 1;
  }


  .upload-box {
    border:2px dashed var(--accent);
    padding:16px;
    border-radius:10px;
    text-align:center;
    background:#f8fbff;
    max-width:400px;
    margin:0 auto 8px;
  }

  canvas {
    display:block;
    max-width:100%;
    height:auto;
    border:1px solid #e6e9ef;
    background:#fff;
  }

  table { width:100%; border-collapse:collapse; margin-top:8px; }
  td,th { padding:6px; border-bottom:1px solid #f0f2f6; font-size:13px; }
  .small { font-size:13px; color:#666; }
  .status { margin-top:8px; color:#333; }
  input[type="number"] {
    width:110px;
    padding:6px;
    border-radius:6px;
    border:1px solid #dbe3ee;
  }
</style>
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
</head>
<body>

<div class="header">
  <div class="logo">
    <a href="landing.html">Map Extract</a>
  </div>
  <div class="nav">
    <a href="use-cases.html">Use Cases</a>
    <a href="landing.html">Home</a>
  </div>
</div>



<div class="container">
  <header>
    <h2>Water Extraction & Georeferencing</h2>
    <div class="controls">
      <button id="btn-georef" class="muted-btn">Georeference Mode</button>
      <button id="btn-clear-gcps" class="secondary">Clear GCPs</button>
      <button id="btn-compute" class="secondary">Compute Transform</button>
      <button id="btn-export-geojson" class="secondary">Export Water GeoJSON</button>
      <button id="btn-ocr-test" class="secondary">Run OCR Test</button>
    </div>
  </header>

  <main>
    <section id="left">
      <div class="upload-box">
        <button id="select-pdf">Select PDF</button>
        <input type="file" id="file-input" accept="application/pdf" style="display:none" />
      </div>

      <div class="status" id="status">No map uploaded</div>
      <canvas id="pdf-canvas"></canvas>
    </section>

    <aside id="right">
      <div id="instructions-section" style="margin-bottom:20px;">
        <h3 id="instructions-toggle" style="cursor:pointer; margin:0;">
          üìò Instructions ‚ñº
        </h3>

        <div id="instructions-content" style="margin-top:10px; font-size:13px; line-height:1.45;">
          <p><strong>1Ô∏è‚É£ Upload your map</strong><br>Click ‚ÄúSelect PDF‚Äù.</p>
          <p><strong>2Ô∏è‚É£ Georeference</strong><br>Toggle Georeference Mode, click points on the map, and enter lon/lat.</p>
          <p><strong>3Ô∏è‚É£ Compute transform</strong><br>Choose affine or polynomial, then click Compute Transform.</p>
          <p><strong>4Ô∏è‚É£ Extract water</strong><br>Click Extract Water to detect water bodies inside the map area.</p>
          <p><strong>5Ô∏è‚É£ Export</strong><br>Export water polygons as GeoJSON for GIS tools.</p>
        </div>
      </div>

      <h3>Ground Control Points</h3>
      <table id="gcp-table">
        <thead>
          <tr><th>px X</th><th>px Y</th><th>lon</th><th>lat</th><th></th></tr>
        </thead>
        <tbody></tbody>
      </table>

      <div style="margin-top:10px">
        <label class="small">Transform Model:</label><br>
        <select id="model-select">
          <option value="affine">Affine (3+ points)</option>
          <option value="poly2">2nd-degree Polynomial (6+ points)</option>
        </select>
      </div>

      <div style="margin-top:12px">
        <div class="small">RMS error:</div>
        <div id="rms" style="font-weight:700;margin-top:4px">‚Äî</div>
      </div>

      <hr style="margin:20px 0"/>

      <div>
        <h3>Water Extraction</h3>
        <button id="btn-extract-water" class="secondary" style="margin-bottom:6px;">Extract Water</button>
        <button id="btn-clear-water" class="secondary">Clear Water</button>

        <div style="margin-top:12px;">
          <label>
            <input type="checkbox" id="chk-water-overlay" checked />
            Show Water Overlay
          </label>
        </div>

        <div class="small" style="margin-top:8px;">
          Water features detected:
          <span id="water-count" style="font-weight:bold;">0</span>
        </div>
      </div>

    </aside>
  </main>
</div>

<script src="./libs/pdf.js"></script>

<script>
pdfjsLib.GlobalWorkerOptions.workerSrc = "./libs/pdf.worker.js";

/* -----------------------------------------------------
   STEP C1 ‚Äî Detect Legend Region (boxed OR unboxed)
----------------------------------------------------- */
/* -----------------------------------------------------
   STEP C2A ‚Äî Improved Legend Region Detection
   Using clustering of OCR text to isolate true legend.
----------------------------------------------------- */
function detectLegendRegion(ocrBoxes, mapBoundary, w, h) {

    // 1. Keep only OCR outside the map interior
    let outside = ocrBoxes.filter(b => {
        const cx = b.x + b.w/2;
        const cy = b.y + b.h/2;
        if (!mapBoundary) return true;
        return !(
            cx > mapBoundary.left &&
            cx < mapBoundary.right &&
            cy > mapBoundary.top &&
            cy < mapBoundary.bottom
        );
    });

    if (outside.length === 0) return null;

    // 2. Compute mean text height to detect large titles
    const meanTextHeight = outside.reduce((s,b)=>s+b.h,0) / outside.length;

    // 3. Remove oversized text (titles / metadata headers)
    outside = outside.filter(b => b.h < meanTextHeight * 1.8);

    if (outside.length === 0) return null;

    // 4. Cluster OCR boxes spatially (DBSCAN-like)
    const clusters = [];
    const visited = new Set();

    function dist(a, b) {
        const ax = a.x + a.w/2, ay = a.y + a.h/2;
        const bx = b.x + b.w/2, by = b.y + b.h/2;
        return Math.hypot(ax - bx, ay - by);
    }

    const radius = 120;  // distance threshold
    const minClusterSize = 3;

    for (let i = 0; i < outside.length; i++) {
        if (visited.has(i)) continue;

        const cluster = [];
        const stack = [i];
        visited.add(i);

        while (stack.length) {
            const idx = stack.pop();
            cluster.push(outside[idx]);

            for (let j = 0; j < outside.length; j++) {
                if (!visited.has(j) && dist(outside[idx], outside[j]) < radius) {
                    visited.add(j);
                    stack.push(j);
                }
            }
        }

        if (cluster.length >= minClusterSize)
            clusters.push(cluster);
    }

    if (clusters.length === 0) return null;

    // 5. Select cluster most likely to be the legend
    let bestCluster = null;
    let bestScore = -Infinity;

    for (const cluster of clusters) {

        const count = cluster.length;

        // Compute bounding box
        const xs = cluster.map(b => b.x);
        const ys = cluster.map(b => b.y);
        const xe = cluster.map(b => b.x + b.w);
        const ye = cluster.map(b => b.y + b.h);

        const width = Math.max(...xe) - Math.min(...xs);
        const height = Math.max(...ye) - Math.min(...ys);

        const aspect = width / (height || 1);

        // score: legend clusters tend to:
        // - have several entries (count)
        // - have moderate aspect ratio
        // - be compact
        const score =
            count * 2 +
            (aspect > 0.4 && aspect < 4 ? 4 : 0) +
            (1 / (width * height + 1)) * 20000;

        if (score > bestScore) {
            bestScore = score;
            bestCluster = cluster;
        }
    }

    if (!bestCluster) return null;

    // Compute final bounding box
    const xs = bestCluster.map(b => b.x);
    const ys = bestCluster.map(b => b.y);
    const xe = bestCluster.map(b => b.x + b.w);
    const ye = bestCluster.map(b => b.y + b.h);

    return {
        left: Math.max(0, Math.min(...xs) - 20),
        top: Math.max(0, Math.min(...ys) - 20),
        right: Math.min(w, Math.max(...xe) + 20),
        bottom: Math.min(h, Math.max(...ye) + 20)
    };
}


/* -----------------------------------------------------
   OCR ‚Äî Extract text bounding boxes
----------------------------------------------------- */
async function extractTextBoxes() {
    statusEl.textContent = "Detecting text‚Ä¶ (OCR)";

    const dataUrl = canvas.toDataURL("image/png");

    const result = await Tesseract.recognize(dataUrl, 'eng', {
        logger: m => console.log(m)
    });

    const boxes = result.data.words.map(w => ({
        x: w.bbox.x0,
        y: w.bbox.y0,
        w: w.bbox.x1 - w.bbox.x0,
        h: w.bbox.y1 - w.bbox.y0,
        text: w.text,
        conf: w.conf
    }));

    console.log("OCR boxes:", boxes);
    statusEl.textContent = "OCR complete.";

    return boxes;
}

/* -----------------------------------------------------
   Compute symbol color/shape signature
----------------------------------------------------- */
function computeSymbolSignature(box, imageData, w, h) {
    const x = box.x;
    const y = box.y;
    const width = box.width ?? box.w;
    const height = box.height ?? box.h;

    let total = 0;
    let sumR = 0, sumG = 0, sumB = 0;
    let darkPix = 0;

    for (let py = y; py < y + height; py++) {
        for (let px = x; px < x + width; px++) {
            const idx = (py * w + px) * 4;
            const r = imageData[idx];
            const g = imageData[idx + 1];
            const b = imageData[idx + 2];

            total++;
            sumR += r; sumG += g; sumB += b;

            const brightness = 0.299*r + 0.587*g + 0.114*b;
            if (brightness < 120) darkPix++;
        }
    }

    return {
        avgColor: [sumR / total, sumG / total, sumB / total],
        darkness: darkPix / total,
        sampleCount: total
    };
}

/* -----------------------------------------------------
   Detect legend symbols located near OCR text labels
----------------------------------------------------- */
function detectLegendSymbols(ocrResults, image, w, h) {

    legendEntries = [];
    legendSymbolBoxes = [];

    for (const item of ocrResults) {

        // Skip text inside map interior
        if (mapBoundary) {
            const cx = item.x + item.w / 2;
            const cy = item.y + item.h / 2;

            if (cx > mapBoundary.left &&
                cx < mapBoundary.right &&
                cy > mapBoundary.top &&
                cy < mapBoundary.bottom) {
                continue;
            }
        }

        const t = {
            x: item.x,
            y: item.y,
            width: item.w,
            height: item.h
        };

        // MUCH tighter search windows
        const midY = t.y + t.height / 2;
        const vertPad = Math.round(t.height * 0.2);
        const padX = 25;  // was t.width * 1.5 (too big)

        const searchRegions = [
            {
                x1: Math.max(0, t.x - padX),
                x2: t.x,
                y1: Math.max(0, midY - vertPad),
                y2: Math.min(h, midY + vertPad)
            },
            {
                x1: t.x + t.width,
                x2: Math.min(w, t.x + t.width + padX),
                y1: Math.max(0, midY - vertPad),
                y2: Math.min(h, midY + vertPad)
            }
        ];

        let symbol = null;

        // Improved color filter
function isInkPixel(r, g, b, x, y) {
    const brightness = 0.299*r + 0.587*g + 0.114*b;

    // --- Detect light / pastel blue water symbol ---
    const pastelBlue =
        b > g + 10 && b > r + 10 &&   // still blue-ish
        brightness > 140 && brightness < 230; // not dark, not white

    // --- Detect hollow road symbols (white interior + dark border) ---
    const dark = brightness < 140;
    let borderHit = false;

    if (!dark) {
        // Check neighbors for a "dark border" pattern
        // (no bounds check needed; caller loop is inside bounds)
        function darkAt(nx, ny) {
              if (nx < 0 || ny < 0 || nx >= w || ny >= h) return false;
              const i = ny * w + nx;
              const di = i * 4;
              const br = 0.299*image[di] + 0.587*image[di+1] + 0.114*image[di+2];
              return br < 140;
          }
          
          if (
              darkAt(x, y - 1) ||
              darkAt(x, y + 1) ||
              darkAt(x + 1, y) ||
              darkAt(x - 1, y)
          ) {
              borderHit = true;
          }
    }
    const isDarkInk = dark;
    const isColoredStrong =
        (b > r + 35 && b > g + 35) ||     // strong blue
        (r > g + 35 && r > b + 35) ||     // strong red
        (g > r + 35 && g > b + 35);       // strong green

    return isDarkInk || isColoredStrong || pastelBlue || borderHit;
}


        for (const region of searchRegions) {

            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let count = 0;

            for (let y = region.y1; y < region.y2; y++) {
                for (let x = region.x1; x < region.x2; x++) {

                    // Skip interior of the map
                    if (mapBoundary &&
                        x > mapBoundary.left &&
                        x < mapBoundary.right &&
                        y > mapBoundary.top &&
                        y < mapBoundary.bottom) continue;

                    const idx = (y * w + x) * 4;
                    const r = image[idx], g = image[idx+1], b = image[idx+2];

                    if (isInkPixel(r, g, b, x, y)) {
                        count++;
                        minX = Math.min(minX, x);
                        maxX = Math.max(maxX, x);
                        minY = Math.min(minY, y);
                        maxY = Math.max(maxY, y);
                    }
                }
            }

            if (count < 10) continue; // was 20; smaller windows ‚Üí need smaller threshold

            const width = maxX - minX;
            const height = maxY - minY;

            // Symbol must be roughly the same height as text
            if (height < t.height * 0.4 || height > t.height * 1.4) continue;

            symbol = { x: minX, y: minY, width, height };
            break;
        }

        if (symbol) {
            const sig = computeSymbolSignature(symbol, image, w, h);

            legendSymbolBoxes.push(symbol);
            legendEntries.push({
                text: item.text,
                textBox: t,
                symbolBox: symbol,
                signature: sig,
                type: "unknown"
            });

        } else {
            legendEntries.push({
                text: item.text,
                textBox: t,
                symbolBox: null,
                type: "unknown"
            });
        }
    }
}


/* -----------------------------------------------------
   STEP C ‚Äî Geometric classification of legend symbols
----------------------------------------------------- */
function classifyLegendEntries(entries, image, w, h) {

    function classify(box) {
        const { x, y, width, height } = box;

        const aspect = width > height ? width/height : height/width;

        let total = 0;
        let ink = 0;

        for (let py = y; py < y + height; py++) {
            for (let px = x; px < x + width; px++) {
                const idx = (py * w + px) * 4;
                const r = image[idx], g = image[idx+1], b = image[idx+2];

                total++;
                const bright = 0.299*r + 0.587*g + 0.114*b;
                if (bright < 200) ink++;
            }
        }

        const fill = ink / total;

        if (width < 25 && height < 25 && aspect < 1.8) return "point";
        if (aspect > 3 && (width < 60 || height < 60)) return "line";
        if (fill > 0.15) return "polygon";

        return "unknown";
    }

    entries.forEach(e => {
        if (!e.symbolBox) e.type = "unknown";
        else e.type = classify(e.symbolBox);
    });
}
/* -----------------------------------------------------
   STEP C2B ‚Äî Symbol-Anchored Legend Region Detection
----------------------------------------------------- */
function detectLegendRegionFromSymbols(legendEntries, w, h) {
    console.log(
      "üü£ detectLegendRegionFromSymbols called ‚Äî entries:",
      legendEntries.length
    );
    // Keep only entries that ACTUALLY have symbols
    const candidates = legendEntries.filter(e => e.symbolBox);

    if (candidates.length === 0) {
        console.warn("üü£ Legend detection failed ‚Äî not enough symbol entries");
        return null;
    }

    // Build bounding box ONLY from symbol-text pairs
    const xs = [];
    const ys = [];
    const xe = [];
    const ye = [];

    candidates.forEach(e => {
        const t = e.textBox;
        const s = e.symbolBox;

        xs.push(t.x, s.x);
        ys.push(t.y, s.y);
        xe.push(t.x + t.width, s.x + s.width);
        ye.push(t.y + t.height, s.y + s.height);
    });

    return {
        left: Math.max(0, Math.min(...xs) - 15),
        top: Math.max(0, Math.min(...ys) - 15),
        right: Math.min(w, Math.max(...xe) + 15),
        bottom: Math.min(h, Math.max(...ye) + 15)
    };
}

</script>

<script>
/* ------------------------------------------------------------------------------------------------

----------------------------------------------------- */
/* ---------- Instructions Toggle ---------- */
const instrToggle = document.getElementById("instructions-toggle");
const instrContent = document.getElementById("instructions-content");
instrToggle.onclick = () => {
  const hidden = instrContent.style.display === "none";
  instrContent.style.display = hidden ? "block" : "none";
  instrToggle.textContent = hidden ? "üìò Instructions ‚ñº" : "üìò Instructions ‚ñ≤";
};

/* ---------- Math Helpers ---------- */
function transpose(A){return A[0].map((_,i)=>A.map(r=>r[i]));}
function matMul(A,B){const R=Array.from({length:A.length},()=>Array(B[0].length).fill(0));
  for(let i=0;i<A.length;i++)for(let j=0;j<B[0].length;j++)for(let k=0;k<B.length;k++)R[i][j]+=A[i][k]*B[k][j];return R;}
function matVecMul(A,v){return A.map(r=>r.reduce((s,x,i)=>s+x*v[i],0));}
function solveLinear(A,b){
  A=A.map(r=>r.slice()); b=b.slice(); const n=A.length;
  for(let i=0;i<n;i++){
    let max=i;
    for(let r=i+1;r<n;r++) if(Math.abs(A[r][i])>Math.abs(A[max][i])) max=r;
    if(max!==i){[A[i],A[max]]=[A[max],A[i]]; [b[i],b[max]]=[b[max],b[i]];}
    const pivot=A[i][i]; if(Math.abs(pivot)<1e-12) throw("Singular");
    for(let j=i;j<n;j++)A[i][j]/=pivot; b[i]/=pivot;
    for(let r=0;r<n;r++){
      if(r===i)continue;
      const f=A[r][i];
      for(let j=i;j<n;j++)A[r][j]-=f*A[i][j];
      b[r]-=f*b[i];
    }
  }
  return b;
}
function leastSquares(M,y){
  const MT=transpose(M);
  const MTM=matMul(MT,M);
  const MTy=matVecMul(MT,y);
  return solveLinear(MTM,MTy);
}

/* ---------- Transform Functions ---------- */
function fitAffine(gcps){
  const M=gcps.map(g=>[1,g.x,g.y]);
  const X=gcps.map(g=>g.X), Y=gcps.map(g=>g.Y);
  const a=leastSquares(M,X), b=leastSquares(M,Y);
  const mapFn=p=>({X:a[0]+a[1]*p.x+a[2]*p.y, Y:b[0]+b[1]*p.x+b[2]*p.y});
  const rms=Math.sqrt(gcps.reduce((s,g)=>{const p=mapFn(g);return s+(p.X-g.X)**2+(p.Y-g.Y)**2;},0)/gcps.length);
  return {mapFn,rms};
}
function fitPoly2(gcps){
  const M=gcps.map(g=>[1,g.x,g.y,g.x*g.x,g.x*g.y,g.y*g.y]);
  const X=gcps.map(g=>g.X), Y=gcps.map(g=>g.Y);
  const a=leastSquares(M,X), b=leastSquares(M,Y);
  const mapFn=p=>{
    const v=[1,p.x,p.y,p.x*p.x,p.x*p.y,p.y*p.y];
    return {
      X:v.reduce((s,_,i)=>s+v[i]*a[i],0),
      Y:v.reduce((s,_,i)=>s+v[i]*b[i],0)
    };
  };
  const rms=Math.sqrt(gcps.reduce((s,g)=>{const p=mapFn(g);return s+(p.X-g.X)**2+(p.Y-g.Y)**2;},0)/gcps.length);
  return {mapFn,rms};
}

/* ---------- State ---------- */
const canvas=document.getElementById("pdf-canvas");
const ctx = canvas.getContext("2d", { willReadFrequently: true });
const fileInput=document.getElementById("file-input");
const selectPdf=document.getElementById("select-pdf");
const btnGeoref=document.getElementById("btn-georef");
const btnClear=document.getElementById("btn-clear-gcps");
const btnCompute=document.getElementById("btn-compute");
const btnExtract=document.getElementById("btn-extract-water");
const btnClearWater=document.getElementById("btn-clear-water");
const btnExport=document.getElementById("btn-export-geojson");
const chkOverlay=document.getElementById("chk-water-overlay");
const waterCount=document.getElementById("water-count");
const statusEl=document.getElementById("status");
const gcpTable=document.querySelector("#gcp-table tbody");
const rmsEl=document.getElementById("rms");
const modelSelect=document.getElementById("model-select");

const btnOCRTest = document.getElementById("btn-ocr-test");

btnOCRTest.onclick = async () => {
    if (!renderedImage) return alert("Load a PDF first.");

    const boxes = await extractTextBoxes();
    ocrBoxesGlobal = boxes;

    const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);

    detectLegendSymbols(boxes, imgData.data, canvas.width, canvas.height);
    console.log("üü£ legendEntries total:", legendEntries.length);
    console.log("üü£ legendEntries with symbolBox:",
      legendEntries.filter(e => e.symbolBox).length
    );
    
    classifyLegendEntries(legendEntries, imgData.data, canvas.width, canvas.height);
    
    legendRegion = detectLegendRegionFromSymbols(
        legendEntries,
        canvas.width,
        canvas.height
    );

    console.log("üü£ Legend region:", legendRegion);

    redrawBase();
};





  
let renderedImage=null;
let georefMode=false;
let gcps=[];
let lastComputed=null;
let waterPixelPolys=[];
let waterFeatures=[];
let showWaterOverlay=true;
let mapBoundary=null; // {left,right,top,bottom}
// generic extracted geometry holders
let extractedPolygons = [];   // polygon features from any extraction
let extractedLines = [];      // line features (future)
let extractedPoints = [];     // point features (future)
let nextFeatureId = 1;        // auto increment ID

// ---------- LEGEND DETECTION STATE ----------
let legendEntries = [];      // { text, textBox, symbolBox }
let legendSymbolBoxes = [];  // boxes we draw on canvas
let ocrBoxesGlobal = [];   // <-- store OCR rectangles so redrawBase() can show them
let legendRegion = null;     // <-- bounding box of legend


/* ---------- Drawing ---------- */
function drawExclusionMask(){
  if(!mapBoundary) return;
  const {left,right,top,bottom}=mapBoundary;
  ctx.save();
  ctx.fillStyle="rgba(0,0,0,0.35)";
  ctx.fillRect(0,0,canvas.width,top);
  ctx.fillRect(0,bottom,canvas.width,canvas.height-bottom);
  ctx.fillRect(0,top,left, bottom-top);
  ctx.fillRect(right,top,canvas.width-right, bottom-top);
  ctx.restore();
}
function drawWaterOverlay(){
  if(!waterPixelPolys.length) return;
  ctx.strokeStyle="rgba(0,120,255,0.9)";
  ctx.fillStyle="rgba(0,120,255,0.18)";
  ctx.lineWidth=2;
  for(const poly of waterPixelPolys){
    ctx.beginPath();
    ctx.moveTo(poly[0][0], poly[0][1]);
    for(let i=1;i<poly.length;i++) ctx.lineTo(poly[i][0], poly[i][1]);
    ctx.closePath(); ctx.fill(); ctx.stroke();
  }
}
function redrawBase() {
    ctx.clearRect(0,0,canvas.width,canvas.height);

    if (renderedImage)
        ctx.drawImage(renderedImage,0,0,canvas.width,canvas.height);

    drawExclusionMask();

    // Draw GCP markers
    gcps.forEach(g=>{
        ctx.fillStyle="rgba(0,120,255,0.9)";
        ctx.beginPath();
        ctx.arc(g.x,g.y,4,0,6.28);
        ctx.fill();
    });

    // Draw water features
    if(showWaterOverlay) drawWaterOverlay();

    ctx.save();

    // 1Ô∏è‚É£ Draw OCR rectangles (RED)
    ctx.strokeStyle = "rgba(255,0,0,0.75)";
    ctx.lineWidth = 2;
    ocrBoxesGlobal.forEach(b => {
        ctx.strokeRect(b.x, b.y, b.w, b.h);
    });
    if (legendRegion) {
        ctx.strokeStyle = "rgba(180, 0, 255, 0.6)";
        ctx.lineWidth = 3;
        ctx.setLineDash([8, 4]);
        ctx.strokeRect(
            legendRegion.left,
            legendRegion.top,
            legendRegion.right - legendRegion.left,
            legendRegion.bottom - legendRegion.top
        );
    }
    // 2Ô∏è‚É£ Draw legend symbol boxes
    legendEntries.forEach(entry => {
        const b = entry.symbolBox;
        if (!b) return;

        let color;

        // Geometry classifier colors
        switch (entry.type) {
            case "point":
                color = "rgba(180, 0, 255, 0.9)";  // purple
                break;
            case "line":
                color = "rgba(0, 200, 0, 0.9)";    // green
                break;
            case "polygon":
                color = "rgba(0, 150, 255, 0.9)";  // blue
                break;
            default:
                color = "yellow";                 // unknown
                break;
        }

        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.strokeRect(b.x, b.y, b.width, b.height);
        ctx.setLineDash([]);

});


    ctx.restore();
}


/* ---------- NEW: Connected Component Map Detection ---------- */
function detectMapBoundaryFromCanvas(){
  const w = canvas.width, h = canvas.height;
  if (!w || !h) return;

  const img = ctx.getImageData(0, 0, w, h);
  const d = img.data;

  // 1. Build ink mask
  const inkMask = new Uint8Array(w * h);
  for (let i = 0; i < w * h; i++) {
    const di = i * 4;
    const r = d[di], g = d[di+1], b = d[di+2];
    const bright = 0.299*r + 0.587*g + 0.114*b;
    inkMask[i] = (bright < 245) ? 1 : 0;
  }

  // 2. Connected components
  const visited = new Uint8Array(w * h);
  let bestSize = 0, bestMinX=0, bestMinY=0, bestMaxX=0, bestMaxY=0;
  const stack = [];
  const dirs = [[1,0],[-1,0],[0,1],[0,-1]];

  for (let y = 0; y < h; y++) {
    for (let x = 0; x < w; x++) {
      const idx = y * w + x;
      if (!inkMask[idx] || visited[idx]) continue;

      let size = 0;
      let minX = x, maxX = x, minY = y, maxY = y;

      stack.push(idx);
      visited[idx] = 1;

      while (stack.length) {
        const i = stack.pop();
        const py = (i / w) | 0;
        const px = i % w;
        size++;

        if (px < minX) minX = px;
        if (px > maxX) maxX = px;
        if (py < minY) minY = py;
        if (py > maxY) maxY = py;

        for (const [dx,dy] of dirs) {
          const nx = px + dx, ny = py + dy;
          if (nx < 0 || ny < 0 || nx >= w || ny >= h) continue;
          const ni = ny * w + nx;
          if (inkMask[ni] && !visited[ni]) {
            visited[ni] = 1;
            stack.push(ni);
          }
        }
      }

      if (size > bestSize) {
        bestSize = size;
        bestMinX = minX; bestMaxX = maxX;
        bestMinY = minY; bestMaxY = maxY;
      }
    }
  }

  if (bestSize === 0) {
    console.warn("No ink regions found; using full image.");
    mapBoundary = null;
    return;
  }

  // 3. Convert to bounding box
  let left   = bestMinX;
  let right  = bestMaxX + 1;
  let top    = bestMinY;
  let bottom = bestMaxY + 1;

  // 4. Shrink inward slightly (Option 2)
  const shrinkX = Math.max(3, Math.round((right-left) * 0.005));
  const shrinkY = Math.max(3, Math.round((bottom-top) * 0.005));

  left   = Math.min(Math.max(0, left   + shrinkX), w);
  right  = Math.max(Math.min(w, right  - shrinkX), 0);
  top    = Math.min(Math.max(0, top    + shrinkY), h);
  bottom = Math.max(Math.min(h, bottom - shrinkY), 0);

  if (left >= right || top >= bottom) {
    console.warn("Boundary collapsed; using full image.");
    mapBoundary = null;
    return;
  }

  mapBoundary = {left, right, top, bottom};
  console.log("Final map interior boundary:", mapBoundary);
}

/* ---------- PDF Loading ---------- */
selectPdf.onclick=()=>fileInput.click();

fileInput.onchange=async()=>{
  const f=fileInput.files[0];
  if(!f) return;

  statusEl.textContent="Loading PDF‚Ä¶";
  waterPixelPolys=[]; waterFeatures=[]; waterCount.textContent="0";

  const ab=await f.arrayBuffer();
  const pdf=await pdfjsLib.getDocument({data:ab}).promise;
  const page=await pdf.getPage(1);
  const viewport=page.getViewport({scale:2});
  canvas.width=viewport.width;
  canvas.height=viewport.height;

  await page.render({canvasContext:ctx,viewport}).promise;

  detectMapBoundaryFromCanvas();

  renderedImage=new Image();
  renderedImage.src=canvas.toDataURL();
  await renderedImage.decode();

  statusEl.textContent="PDF loaded.";
  redrawBase();
};

/* ---------- GCPs ---------- */
btnGeoref.onclick=()=>{
  georefMode=!georefMode;
  btnGeoref.textContent=georefMode?"Exit Georeference Mode":"Georeference Mode";
  btnGeoref.className=georefMode?"danger":"muted-btn";
  redrawBase();
};

canvas.addEventListener("click",e=>{
  if(!georefMode || !renderedImage) return;
  const r=canvas.getBoundingClientRect();
  const x=(e.clientX-r.left)*(canvas.width/r.width);
  const y=(e.clientY-r.top)*(canvas.height/r.height);
  gcps.push({x,y,X:null,Y:null});
  refreshTable(); redrawBase();
});

function refreshTable(){
  gcpTable.innerHTML="";
  gcps.forEach((g,i)=>{
    const tr=document.createElement("tr");

    const t1=document.createElement("td"); t1.textContent=g.x.toFixed(1);
    const t2=document.createElement("td"); t2.textContent=g.y.toFixed(1);

    const lonTD=document.createElement("td");
    const lon=document.createElement("input");
    lon.type="number"; lon.step="any"; lon.value=g.X ?? "";
    lon.onchange=()=>g.X=parseFloat(lon.value);
    lonTD.appendChild(lon);

    const latTD=document.createElement("td");
    const lat=document.createElement("input");
    lat.type="number"; lat.step="any"; lat.value=g.Y ?? "";
    lat.onchange=()=>g.Y=parseFloat(lat.value);
    latTD.appendChild(lat);

    const del=document.createElement("td");
    const btn=document.createElement("button");
    btn.textContent="X"; btn.className="secondary";
    btn.onclick=()=>{gcps.splice(i,1); refreshTable(); redrawBase();};
    del.appendChild(btn);

    tr.appendChild(t1); tr.appendChild(t2);
    tr.appendChild(lonTD); tr.appendChild(latTD);
    tr.appendChild(del);

    gcpTable.appendChild(tr);
  });
}

/* ---------- Compute Transform ---------- */
btnCompute.onclick=()=>{
  const valid=gcps.filter(g=>typeof g.X==="number" && typeof g.Y==="number");
  if(modelSelect.value==="affine" && valid.length<3) return alert("Affine requires ‚â•3 GCPs");
  if(modelSelect.value==="poly2" && valid.length<6) return alert("Poly2 requires ‚â•6 GCPs");

  try{
    lastComputed=modelSelect.value==="affine" ? 
      fitAffine(valid) : fitPoly2(valid);

    rmsEl.textContent=lastComputed.rms.toFixed(3);
    statusEl.textContent="Transform computed.";
    redrawBase();
  }catch(err){
    alert("Failed: "+err);
  }
};

/* ---------- Water Extraction ---------- */
function isWaterPixel(r,g,b){
  return (b > 120 && b > r+25 && b > g+15);
}

function getWaterMask(){
  if(!renderedImage){
    return new Uint8Array(canvas.width*canvas.height);
  }
  const w=canvas.width, h=canvas.height;

  const off=document.createElement("canvas");
  off.width=w; off.height=h;
  const octx=off.getContext("2d");
  octx.drawImage(renderedImage,0,0,w,h);

  const img=octx.getImageData(0,0,w,h);
  const d=img.data;
  const mask=new Uint8Array(w*h);

  const useBoundary=!!mapBoundary;
  const left  = useBoundary? mapBoundary.left   : 0;
  const right = useBoundary? mapBoundary.right  : w;
  const top   = useBoundary? mapBoundary.top    : 0;
  const bottom= useBoundary? mapBoundary.bottom : h;

  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const idx=y*w+x;

      // outside map interior ‚Üí no water
      if(x < left || x >= right || y < top || y >= bottom){
        mask[idx]=0; continue;
      }

      const di=idx*4;
      const r=d[di], g=d[di+1], b=d[di+2];
      mask[idx] = isWaterPixel(r,g,b) ? 1 : 0;
    }
  }
  return mask;
}

function perpendicularDistance(pt, lineStart, lineEnd){
  const [x,y]=pt;
  const [x1,y1]=lineStart;
  const [x2,y2]=lineEnd;
  const dx=x2-x1, dy=y2-y1;
  if(dx===0 && dy===0) return Math.hypot(x-x1,y-y1);
  const t=((x-x1)*dx+(y-y1)*dy)/(dx*dx+dy*dy);
  const projX=x1+t*dx, projY=y1+t*dy;
  return Math.hypot(x-projX,y-projY);
}
function simplifyRDP(points,epsilon){
  if(points.length<=2) return points.slice();
  let maxDist=0, index=-1;
  for(let i=1;i<points.length-1;i++){
    const d=perpendicularDistance(points[i],
      points[0], points[points.length-1]);
    if(d>maxDist){maxDist=d; index=i;}
  }
  if(maxDist>epsilon){
    const left=simplifyRDP(points.slice(0,index+1),epsilon);
    const right=simplifyRDP(points.slice(index),epsilon);
    return left.slice(0,left.length-1).concat(right);
  }
  return [points[0], points[points.length-1]];
}

function extractWaterRegions(mask,w,h){
  const visited=new Uint8Array(w*h);
  const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
  const regions=[];

  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const idx=y*w+x;
      if(mask[idx]===1 && !visited[idx]){
        const stack=[idx];
        visited[idx]=1;
        const region=[];
        while(stack.length){
          const i=stack.pop();
          region.push(i);
          const py=(i/w)|0, px=i%w;
          for(const[dx,dy] of dirs){
            const nx=px+dx, ny=py+dy;
            if(nx<0||ny<0||nx>=w||ny>=h) continue;
            const ni=ny*w+nx;
            if(mask[ni]===1 && !visited[ni]){
              visited[ni]=1; stack.push(ni);
            }
          }
        }

        if(region.length < 50) continue;
        const set=new Set(region);
        const boundary=[];
        for(const i of region){
          const py=(i/w)|0, px=i%w;
          let isB=false;
          for(const[dx,dy] of dirs){
            const nx=px+dx, ny=py+dy;
            if(nx<0||ny<0||nx>=w||ny>=h){isB=true; break;}
            if(!set.has(ny*w+nx)){isB=true; break;}
          }
          if(isB) boundary.push([px+0.5,py+0.5]);
        }
        if(boundary.length < 3) continue;

        let cx=0,cy=0;
        for(const p of boundary){cx+=p[0];cy+=p[1];}
        cx/=boundary.length; cy/=boundary.length;

        boundary.sort((a,b)=>{
          const aa=Math.atan2(a[1]-cy,a[0]-cx);
          const bb=Math.atan2(b[1]-cy,b[0]-cx);
          return aa-bb;
        });

        let simple=simplifyRDP(boundary,1.5);
        if(simple.length>2){
          const f=simple[0], l=simple[simple.length-1];
          if(f[0]!==l[0] || f[1]!==l[1]) simple.push([f[0],f[1]]);
          regions.push(simple);
        }
      }
    }
  }
  return regions;
}

function pixelPolyToFeature(poly,mapFn){
  const coords=poly.map(([x,y])=>{
    const g=mapFn({x,y});
    return [g.X,g.Y];
  });
  return {
    type:"Feature",
    properties:{type:"water"},
    geometry:{type:"Polygon",coordinates:[coords]}
  };
}
function createFeatureRecord(type, geometry) {
    return {
        id: nextFeatureId++,
        type,     // "polygon", "line", or "point"
        geometry, // raw pixel coordinates OR georeferenced later
        name: null  // user will rename later
    };
}
  
btnExtract.onclick = () => {
  if (!renderedImage) return alert("Load a PDF first.");
  if (!lastComputed) return alert("Compute transform first.");

  statusEl.textContent = "Extracting water‚Ä¶";

  const mask = getWaterMask();
  const polys = extractWaterRegions(mask, canvas.width, canvas.height);

  waterPixelPolys = polys;
  waterFeatures = polys.map(p => pixelPolyToFeature(p, lastComputed.mapFn));
  waterCount.textContent = polys.length.toString();

  // NEW: store polygons generically
  polys.forEach(poly => {
    extractedPolygons.push(
      createFeatureRecord("polygon", poly)
    );
  });

  redrawBase();
  statusEl.textContent = `Water extraction complete (${polys.length} regions).`;
};


btnClearWater.onclick=()=>{
  waterPixelPolys=[];
  waterFeatures=[];
  waterCount.textContent="0";
  redrawBase();
  statusEl.textContent="Water cleared.";
};

chkOverlay.onchange=e=>{
  showWaterOverlay=e.target.checked;
  redrawBase();
};

btnExport.onclick=()=>{
  if(waterFeatures.length===0) return alert("No water features.");
  const fc={type:"FeatureCollection",features:waterFeatures};
  const blob=new Blob([JSON.stringify(fc,null,2)],{type:"application/json"});
  const url=URL.createObjectURL(blob);
  const a=document.createElement("a");
  a.href=url; a.download="water.geojson"; a.click();
  URL.revokeObjectURL(url);
};
</script>
</body>
</html>
